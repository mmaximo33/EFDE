#!/usr/bin/env bash
set -euo pipefail

_mod_.console_clear() {
  # Todo: Determinar si es linux,windows, mac
  clear
}

#_mod_.check_mode_debug() {
#  [ "$EFDE_MOD_DEBUG" == "true" ] || [ "$EFDE_MOD_DEBUG" == "core" ]
#}

_mod_.msg_debug(){
    local level="${2:-0}"
    local end="${3:-0}"
    local prefix=""

    if [ "$level" -eq 1 ]; then
      prefix+="├──"
    fi
    if [ "$level" -gt 1 ]; then
      for ((i=1; i<level; i++)); do
        prefix+="│   "
      done
      if [ "$end" -eq 0 ]; then
        prefix+="├──"
      else
        prefix+="└──"
      fi
    fi

    _mod_msg_print "$prefix $1" "debug"
}

_mod_msg_print(){
    local color_start=""
    local color_end=""
    if [ "$2" == "debug" ]; then
        local color_start="\033[1;35m"
        local color_end="\033[0m"
    fi

    if [ "$EFDE_MOD_DEBUG" = "true" ] ; then
      command printf "${color_start}$1${color_end}\n" 2>/dev/null
    fi
}

_mod_.msg_danger(){
    local level="${2:-0}"
    if [ "$EFDE_MOD_DEBUG" = "true" ] ; then
      _mod_.msg_debug "\033[1;31m$1\033[0m" $level
    else
      command printf "\033[1;31m$1\033[0m\n" 2>/dev/null
    fi
}

_mod_.load_module(){
  local PATH_MODULE=$1
  local elements=("props" "tasks")

  _mod_.msg_debug "Module: $MODULE_NAME" 1

  for element in "${elements[@]}"; do
    CHECK_PATH="$PATH_MODULE/$element"
    if [ -d "$CHECK_PATH" ]; then
      _mod_.msg_debug "Group: $element" 2
      for file in $(ls -1 $CHECK_PATH); do
        _mod_.msg_debug "Element: $file" 3
        _mod_.replacemod  --file-name="$file" --new-name="$MODULE_NAME.$element.${file%}" --source-path="$CHECK_PATH/$file"
      done
    fi
  done
}

_mod_.replacemod () {
  local FILE_NAME NEW_NAME SOURCE_PATH
  local USED="The '$FUNCNAME' method must contain the 3 required parameters \n--file-name='file \n--new-name='common.task' \n--source-path='path/folder/file"

  if [[  $# != 3 ]]; then
    _mod_.msg_danger $USED 3
    _mod_.msg_debug "$@" 3
    exit 1;
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --file-name=*)    FILE_NAME="${1#*=}";    shift ;;
      --new-name=*)     NEW_NAME="${1#*=}";     shift ;;
      --source-path=*)  SOURCE_PATH="${1#*=}";  shift ;;
      *)
        _mod_.msg_danger $USED
        exit 1
        ;;
    esac
  done

  if [[ -z "$FILE_NAME" || -z "$NEW_NAME" || -z "$SOURCE_PATH"  ]]; then
    _mod_.msg_danger $USED
    exit 1
  fi

  PATH_TARGET="$DIRECTORY_TMP/$NEW_NAME"
  _mod_.msg_debug "New File: $NEW_NAME" 4
  _mod_.msg_debug "Path $SOURCE_PATH" 4
  _mod_.msg_debug "Path Tmp: $PATH_TARGET" 4


  if [ "$EFDE_MOD_DEV" = "true" ] || [ ! -f "$PATH_TARGET" ]; then
    sed "s/_mod_/$NEW_NAME/g" "$SOURCE_PATH" > "$PATH_TARGET"
    if [ ! $? -eq 0 ]; then
      _mod_.msg_danger "[ERROR] The conversion could not be carried out, report this!" 4
      _mod_.msg_danger "Source: $SOURCE_PATH" 5
      _mod_.msg_danger "Target: $PATH_TARGET" 5
    fi
  fi

  source "$PATH_TARGET"
  if [ ! $? -eq 0 ]; then
    _mod_.msg_danger "[ERROR] The resources were not loaded, report this!" 4
    _mod_.msg_danger "File: $NEW_NAME" 5
    _mod_.msg_danger "Path: $PATH_TARGET" 5
    exit 1
  fi
}